#!/usr/bin/env python

import argparse

try:
    import configparser
except ImportError:
    import ConfigParser as configparser

import logging
import os
import sys
import stat
import subprocess
#import platform
import atexit
import signal
import ctypes
import shlex
"""
libc = ctypes.CDLL("libc.so.6")

def set_pdeathsig(sig=signal.SIGTERM):
    def callable():
        return libc.prctl(1, sig)
    return callable
"""
procs = []

logging.basicConfig(level=logging.DEBUG, format='%(asctime)s %(message)s')
_log = logging.getLogger()

@atexit.register
def kill_subprocesses(*args, **kwargs):
    for proc in procs:
        if proc.returncode == None:
            _log.debug('killing %s at exit', proc)
        try:
            proc.kill()
            proc.terminate()
        except:
            pass

def sig_term(*args, **kwargs):
#    kill_subprocesses()
    sys.exit(signal.SIGTERM | 0x80)

signal.signal(signal.SIGTERM, sig_term)

def check_call_and_terminate(*args, **kwargs):
    pp = subprocess.Popen(*args, **kwargs)
    procs.append(pp)
    retcode = pp.wait()
    if retcode:
        raise subprocess.CalledProcessError(retcode, args[0])
    return retcode

learning_task_dir_name = 'learningtasks'
cplint_dir_name = 'cplint'
data_dir_name = 'data'
tool_specific_data_dir = 'slipcover'
lp_dir_name = 'lp'
config_file_name = 'slipcover.conf'
#output_file_name = 'results.txt'
swipl_executable_name = 'swipl'
slipcover_script_name = 'slipcover.pl'
slipcover_rules_output_file_name = 'rules'
train_script_file_name = 'train.sh'
extract_inter_script = "extract_facts.pl"

class NoSwiplInstallationFoundException(Exception):
    """Raised when no installed SWI-Prolog could be found."""


class NoSLIPCOVERScriptFound(Exception):
    """Raised when no SLIPCOVER script could be found"""


def copy_files_around(task_id, lp_id, target_dir, file_name_base, file_pos_path,
                      file_neg_path, prolog):
    """Finds all the files necessary to run slipcover:
    - ../../learningtasks/<task_id>/cplint/data/slipcover/*.pl
                            --> <target_dir>/<file_name_base>.pl
    - ../../learningtasks/<task_id>/cplint/data/*.pl  # merged!
                            --> <target_dir>/<file_name_base>.pl
    - file_pos              --> <target_dir>/<file_name_base>.pl # interpretation extraction and merge! 
    - file_neg              --> <target_dir>/<file_name_base>.pl # interpretation extraction and merge!
    """
    # <file_name_base>.b (background knowledge)
    data_dir = os.path.join('..', '..', learning_task_dir_name, task_id,
                            cplint_dir_name, data_dir_name)
    tool_specific_dir = os.path.join(
        '..', '..', learning_task_dir_name, task_id, cplint_dir_name,
        data_dir_name, tool_specific_data_dir)
    
    _log.debug("Converting the dataset in a supported format by SLIPCOVER.")
    # open the file that will be taken as input by SLIPCOVER
    out = open(os.path.join(target_dir, file_name_base + '.pl'), 'w')
    
    ## For slipcover the examples, the settings, the background knowledge, the initial knowledge go all in one file.
    ## and some predicates must be set (e.g. :- sc.)
    out.write(":- sc.\n")
    out.flush()
    
        # add the language biases
    # ../../learningtasks/<task_id>/cplint/data/slipcover/*.pl
    #                    --> <target_dir>/<file_name_base>.pl
    if os.path.isdir(tool_specific_dir):
        for f_name in os.listdir(tool_specific_dir):
            if f_name.endswith('.pl'):
                subprocess.call(['cat', f_name], cwd=tool_specific_dir,
                                stdout=out)   
    
    out.flush()

    # open a temporary file that will contain the merge of all the programs (ONLY ONE FILE IS SUPPORTED!!)  
    # merge all kb files into one
    # ../../learningtasks/<task_id>/cplint/data/*.pl  # merged!
    #                    --> <target_dir>/<file_name_base>.pl
    for f_name in os.listdir(data_dir):
        if f_name.endswith('.pl'):
            subprocess.call(['cat', f_name], cwd=data_dir, stdout=out)
            
    out.flush() 
    
    extract_inter_script_path = os.path.join(os.getcwd(),extract_inter_script)
    
    # convert the positive examples
    file_pos_converted_path = os.path.join(target_dir, "file_pos_converted.pl")
    
    command = prolog + " --quiet -l " + extract_inter_script_path + " -g "

    args = shlex.split(command)
    args.append("extract_pos_examples(\'%s\',\'%s\'),halt." % (file_pos_path, file_pos_converted_path))
    
    subprocess.call(args, cwd=os.getcwd())
    # copy the converted negative examples
    subprocess.call(['cat', file_pos_converted_path], cwd=target_dir, stdout=out)
    # remove file containing the converted positive examples
    os.remove(file_pos_converted_path)
    
    
    # convert the negative examples
    file_neg_converted_path = os.path.join(target_dir, "file_neg_converted.pl")
    
    command = prolog + " --quiet -l " + extract_inter_script_path + " -g "

    args = shlex.split(command)
    args.append("extract_neg_examples(\'%s\',\'%s\'),halt." % (file_neg_path, file_neg_converted_path))
    
    subprocess.call(args, cwd=os.getcwd())
    # copy converted negative examples
    subprocess.call(['cat', file_neg_converted_path], cwd=target_dir, stdout=out)
    # remove file containing the converted negative examples
    os.remove(file_neg_converted_path)
    
    # all examples in one fold
    out.write("fold(all,F) :- findall(I,int(I),F).")
    # close the final file 
    out.close()
    
    _log.debug("Conversion completed")
    # return the final file
    return os.path.join(target_dir, file_name_base + ".pl")


def get_settings(learning_task, lp_id):
    config_file_path = os.path.join('..', '..', learning_task_dir_name,
                                    learning_task, cplint_dir_name,
                                    lp_dir_name, lp_id, config_file_name)

    if not os.path.isfile(config_file_path):
        return {}

    conf = configparser.ConfigParser()
    conf.read(config_file_path)

    settings = {}
    for item in conf.items('main'):
        setting, raw_value = item
        settings[setting] = raw_value

    return settings


def find_swipl():
    swipl_exec_path = subprocess.check_output(['which', swipl_executable_name])
    swipl_exec_path = swipl_exec_path.strip()

    if swipl_exec_path == '':
        msg = 'No SWI-Prolog installation could be found. Please make sure you ' \
                  'have SWI-Prolog installed via your package manager or download ' \
                  'and manually install it ' \
                  'from http://www.swi-prolog.org/Download.html'
        raise NoSwiplInstallationFoundException(msg)

    return swipl_exec_path

# It finds where is the script 'slipcover.pl' 
def find_slipcover_script():
    if os.path.isfile(os.path.join(os.getcwd(), slipcover_script_name)):
        # SLIPCOVER executable resides in the same directory
        return os.path.join(os.getcwd(), slipcover_script_name)

    else:
        try:
            slipcover_script_path = subprocess.check_output(
                ['locate', slipcover_script_name]).strip().split('\n')[0]
        except subprocess.CalledProcessError:
            slipcover_script_path = ''

        if slipcover_script_path == '':
            msg = 'No %s script could be found. Please download it ' \
                  'from https://sites.google.com/a/unife.it/ml/slipcover ' \
                  'or copy it from ~/lib/swipl/pack/cplint/prolog after ' \
                  'you have installed the cplint pack ' \
                  'and put it into the learning ' \
                  'system\'s directory' % (slipcover_script_name)
            raise NoSLIPCOVERScriptFound(msg)

        return slipcover_script_path

# create the executable that shall be launched to run SLIPCOVER
def create_exec_script(swipl_executable, slipcover_script_path, input_file_path, target_dir, settings):
    """ create the executable that shall be launched to run SLIPCOVER
        :returns: two values: the path of the executable and the path of the file containing the learned rules
    """
    file_path = os.path.join(target_dir, train_script_file_name)
    slipcover_rules_path = os.path.join(target_dir, slipcover_rules_output_file_name)

    settings_str = ''

    for key, val in settings.items():
        settings_str += 'set_sc(%s,%s)' % (key, val)
        settings_str += ','

    settings_str = settings_str[:-1]
    
    cmd = ("echo \"consult('%s'),%s,induce([all],P),numbervars(P,0,_),print(P),halt.\" | %s %s 1> %s\n" %  
        (input_file_path,settings_str,swipl_executable,slipcover_script_path,slipcover_rules_path))
    #cmd = ("echo \"consult('%s'),%s,induce([all],P),print(P),halt.\" | %s %s 1> %s\n" %  
    #    (input_file_path,settings_str,swipl_executable,slipcover_script_path,slipcover_rules_path))

    # write the train script
    with open(file_path, 'w') as f:
        f.write("#!/bin/bash\n\n")
        f.write(cmd)

    # make the train script executable
    os.chmod(file_path, stat.S_IRWXU)
    
    return file_path,slipcover_rules_path


def get_and_clean_results(results_file):
    result_lines = []

    # get all result lines from results file
    #with open(os.path.join(results_dir, aleph_rules_output_file_name)) as res:
    with open(results_file) as res:
        for line in res.readlines():
            result_lines.append(line.strip())
    """
    tmp_lines = []
    tmp_line = ''

    for line in result_lines:
        tmp_line += line
        if line.strip().endswith('.'):
            tmp_lines.append(tmp_line)
            tmp_line = ''

    result_lines = tmp_lines
    # remove all pos examples that could not be generalized
    with open(os.path.join(target_dir, file_name_base + '.f')) as examples:
        for line in examples.readlines():
            line = line.strip()
            if line in result_lines:
                result_lines.remove(line)
    """
    return result_lines


def read_config(path):
    conf = configparser.ConfigParser()
    conf.read(path)

    settings = {}
    for item in conf.items('main'):
        setting, raw_value = item
        settings[setting] = raw_value

    for item in conf.items('filename'):
        setting, raw_value = item
        settings['filename.' + setting] = raw_value

    for item in conf.items('data'):
        setting, raw_value = item
        settings['data.' + setting] = raw_value

    return settings


if __name__ == '__main__':
    argparser = argparse.ArgumentParser()
    argparser.add_argument('config_file')
    args = argparser.parse_args()

    cfg = read_config(args.config_file)

    learning_task_id = cfg['learningtask']
    learning_problem_id = cfg['learningproblem']
    output_file = cfg['output']
    _log.debug('Running learning task %s with learning problem %s' % (
        learning_task_id, learning_problem_id))

    file_name_base = learning_task_id + '_' + learning_problem_id
    target_dir = cfg['data.workdir']
    _log.debug('Target dir is %s' % target_dir)
    swipl_executable = find_swipl()
    input_file_path = copy_files_around(learning_task_id, learning_problem_id, target_dir,
                      file_name_base, cfg['filename.pos'], cfg['filename.neg'],prolog=swipl_executable)

    settings = get_settings(learning_task_id, learning_problem_id)
    
    slipcover_script_path = find_slipcover_script()
    script_path,learned_rules_path = create_exec_script(swipl_executable, slipcover_script_path, input_file_path, target_dir, settings)
    # script_path = os.path.join(target_dir, train_script_file_name)

    _log.debug('Running SLIPCOVER')
    check_call_and_terminate([script_path], cwd=target_dir)
    

    _log.debug('Postprocessing output files')
    results = get_and_clean_results(learned_rules_path)

    with open(output_file, 'w') as out:
        for line in results:
            out.write(line + "\n")
    _log.debug('Postprocessing finished')
    _log.debug('SLIPCOVER run finished.')
    _log.debug('Results written to %s' % output_file)
