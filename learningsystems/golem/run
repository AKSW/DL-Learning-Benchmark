#!/usr/bin/env python

import argparse

try:
    import configparser
except ImportError:
    import ConfigParser as configparser

import logging
import os
import shutil
import subprocess
import platform
import tempfile

logging.basicConfig(level=logging.DEBUG, format='%(asctime)s %(message)s')
_log = logging.getLogger()

learning_task_dir_name = 'learningtasks'
prolog_dir_name = 'prolog'
data_dir_name = 'data'
tool_specific_data_dir = 'golem'
lp_dir_name = 'lp'
pos_file_name = 'pos.pl'
neg_file_name = 'neg.pl'
settings_pattern = '!- set(%s,%s).'
config_file_name = 'golem.conf'
output_file_name = 'results.txt'
exec_file_name = 'golem'


def find_golem():
    gen_path = os.path.join(os.getcwd(),
                            '%s-%s' % (platform.system(), platform.machine()),
                            exec_file_name)

    if os.path.isfile(gen_path):
        # golem executable resides in the same directory
        return gen_path

    else:
        # golem executable resides somewhere else; it is assumed that it can be
        # found somewhere in the system path
        return exec_file_name


def get_settings(learning_task, lp_id):
    config_file_path = os.path.join('..', '..', learning_task_dir_name,
                                    learning_task, prolog_dir_name,
                                    lp_dir_name, lp_id, config_file_name)

    if not os.path.isfile(config_file_path):
        return {}

    conf = configparser.ConfigParser()
    conf.read(config_file_path)

    settings = {}
    for item in conf.items('main'):
        setting, raw_value = item
        settings[setting] = raw_value

    return settings


def read_config(path):
    conf = configparser.ConfigParser()
    conf.read(path)

    settings = {}
    for item in conf.items('main'):
        setting, raw_value = item
        settings[setting] = raw_value

    for item in conf.items('filename'):
        setting, raw_value = item
        settings['filename.'+setting] = raw_value

    for item in conf.items('data'):
        setting, raw_value = item
        settings['data.'+setting] = raw_value

    return settings


def copy_files_around(task_id, lp_id, target_dir, file_name_base):
    """Finds all the files necessary to run golem:
    - ../../../learningtasks/<task_id>/prolog/data/*.pl  # merged!
                            --> <target_dir>/<file_name_base>.b
    - ../../learningtasks/<task_id>/prolog/lp/<lp_id>/pos.pl
                            --> <target_dir>/<file_name_base>.f
    - ../../learningtasks/<task_id>/prolog/lp/<lp_id>/neg.pl
                            --> <target_dir>/<file_name_base>.n
    """
    # <file_name_base>.b (background knowledge)
    data_dir = os.path.join('..', '..', learning_task_dir_name, task_id,
                            prolog_dir_name, data_dir_name)
    tool_specific_dir = os.path.join(
        '..', '..', learning_task_dir_name, task_id, prolog_dir_name,
        data_dir_name, tool_specific_data_dir)

    # merge all kb files into one
    with open(os.path.join(target_dir, file_name_base+'.b'), 'w') as out:
        if os.path.isdir(tool_specific_dir):
            for f_name in os.listdir(tool_specific_dir):
                if f_name.endswith('.pl'):
                    subprocess.call(['cat', f_name], cwd=tool_specific_dir,
                                    stdout=out)
        for f_name in os.listdir(data_dir):
            if f_name.endswith('.pl'):
                subprocess.call(['cat', f_name], cwd=data_dir, stdout=out)
        out.flush()

        settings = get_settings(task_id, lp_id)

        for k, v in settings.items():
            out.write(settings_pattern % (k, v))
            out.write(os.linesep)

    pos_file_path = os.path.join('..', '..', learning_task_dir_name, task_id,
                                 prolog_dir_name, lp_dir_name, lp_id,
                                 pos_file_name)
    pos_target_file_path = os.path.join(target_dir, file_name_base+'.f')
    subprocess.call(['cp', pos_file_path, pos_target_file_path])

    neg_file_path = os.path.join('..', '..', learning_task_dir_name, task_id,
                                prolog_dir_name, lp_dir_name, lp_id,
                                neg_file_name)
    neg_target_file = os.path.join(target_dir, file_name_base+'.n')
    subprocess.call(['cp', neg_file_path, neg_target_file])

    # Create the <file_name_base>.r results file
    # (just to avoid the Golem message [Cannot find <file_name_base>.r])
    open(os.path.join(target_dir, file_name_base+'.r'), 'a').close()


def get_and_clean_results(results_dir, f_name_base):
    result_lines = []
    # get all result lines from results file
    with open(os.path.join(results_dir, f_name_base + '.r')) as res:
        for line in res.readlines():
            result_lines.append(line.strip())

    # FIXME: This split-at-').'-and-join-again approach is too weak
    # remove all line breaks and spit again one rule per line
    result_lines = ''.join(result_lines).split(').')
    # add dots (removed in previous line) to rules again
    result_lines = [l + ').' for l in result_lines if l != '']

    # remove all pos examples that could not be generalized
    with open(os.path.join(target_dir, f_name_base + '.f')) as examples:
        for line in examples.readlines():
            line = line.strip()
            if line in result_lines:
                result_lines.remove(line)

    return result_lines


def clean_up(tmp_dir):
    shutil.rmtree(tmp_dir)


if __name__ == '__main__':
    argparser = argparse.ArgumentParser()
    argparser.add_argument('config_file')
    args = argparser.parse_args()

    cfg = read_config(args.config_file)
    learning_task_id = cfg['learningtask']
    learning_problem_id = cfg['learningproblem']
    output_file = cfg['output']
    _log.debug('Running learning task %s with learning problem %s' % (
        learning_task_id, learning_problem_id))

    file_name_base = learning_task_id + '_' + learning_problem_id
    file_name_base = 'data'
    target_dir = cfg['data.workdir']
    _log.debug('Target dir is %s' % target_dir)

    copy_files_around(learning_task_id, learning_problem_id, target_dir,
                      file_name_base)

    golem_executable = find_golem()
    _log.debug('Runnig Golem')
    subprocess.check_call([golem_executable, file_name_base], cwd=target_dir)

    results = get_and_clean_results(target_dir, file_name_base)

    with open(output_file, 'w') as out:
        for line in results:
            out.write(line + os.linesep)

    _log.debug('Golem run finished. Cleaning up.')
    #clean_up(target_dir)
    _log.debug('Done. Results written to %s' % output_file)
